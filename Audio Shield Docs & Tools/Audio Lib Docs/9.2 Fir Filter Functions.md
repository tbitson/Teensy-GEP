AudioFilterFIRSummaryFinite impulse response filter, useful for all sorts of filtering.Audio ConnectionsPort	PurposeIn 0	Signal to be filteredOut 0	Filtered Signal OutputFunctionsbegin(array, length);Initialize the filter. The array must be 16 bit integers (the filter's impulse response), and length indicates the number of points in the array. Array may also be FIR_PASSTHRU (length = 0), to directly pass the input to output without filtering.end();Turn the filter off.ExamplesFile > Examples > Audio > Effects > Filter_FIRKnown IssuesYour filter's impulse response array must have an even length. If you have add odd number of taps, you must add an extra zero to increase the length to an even number.The minimum number of taps is 4. If you use less, add extra zeros to increase the length to 4.The impulse response must be given in reverse order. Many filters have symetrical impluse response, making this a non-issue. If your filter has a non-symetrical response, make sure the data is in reverse time order.NotesFIR filters requires more CPU time than Biquad (IIR), but they can implement filters with better phase response.A 100 point filter requires 9% CPU time on Teensy 3.1. The maximum supported filter length is 200 points.The free TFilter Design Tool can be used to create the impulse response array. Be sure to set the sampling frequency to 44117 HZ (it defaults to only 2000 Hz) and the output type to "int" (16 bit).If you use TFilter Design's "C/C++ array" option, it's output has "int" definition, which is 32 bits on Teensy 3.1. Edit "int" to "short" for an array of 16 bit numbers, and add "const" to avoid consuming extra RAM.